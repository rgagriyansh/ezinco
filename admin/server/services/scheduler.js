import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';
import { generateBlogContent, generateTitle, generateMetaDescription, generateTags } from './openai.js';
import { humanizeText } from './humanizer.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const settingsPath = join(__dirname, '..', 'data', 'settings.json');
const blogsPath = join(__dirname, '..', 'data', 'blogs.json');
const keywordsPath = join(__dirname, '..', 'data', 'keywords.json');

// Get settings
async function getSettings() {
  const data = await fs.readFile(settingsPath, 'utf-8');
  return JSON.parse(data);
}

// Get blogs data
async function getBlogsData() {
  try {
    const data = await fs.readFile(blogsPath, 'utf-8');
    return JSON.parse(data);
  } catch {
    return { blogs: [], lastPostTime: null };
  }
}

// Save blogs data
async function saveBlogsData(data) {
  await fs.writeFile(blogsPath, JSON.stringify(data, null, 2));
}

// Get keywords
async function getKeywords() {
  const data = await fs.readFile(keywordsPath, 'utf-8');
  return JSON.parse(data);
}

// Get random keyword that hasn't been used recently
async function getNextKeyword() {
  const { keywords } = await getKeywords();
  const { blogs } = await getBlogsData();
  
  if (keywords.length === 0) {
    throw new Error('No keywords configured');
  }
  
  // Get keywords used in last 10 posts
  const recentKeywords = blogs
    .filter(b => b.isAutoGenerated)
    .slice(0, 10)
    .map(b => b.keyword);
  
  // Filter out recently used keywords
  const availableKeywords = keywords.filter(k => !recentKeywords.includes(k));
  
  // If all keywords used recently, pick from all
  const keywordPool = availableKeywords.length > 0 ? availableKeywords : keywords;
  
  return keywordPool[Math.floor(Math.random() * keywordPool.length)];
}

// Generate slug from keyword
function generateSlug(keyword, title) {
  const base = (title || keyword)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '')
    .substring(0, 50);
  
  return `${base}-${Date.now().toString(36)}`;
}

// Check if we can post (rate limiting)
async function canPost() {
  const settings = await getSettings();
  const blogsData = await getBlogsData();
  
  // Check environment variables first, then settings file
  const autoPostEnabled = process.env.AUTO_POST_ENABLED === 'true' || process.env.AUTO_POST_ENABLED === '1' || settings.autoPostEnabled;
  const openaiApiKey = process.env.OPENAI_API_KEY || settings.openaiApiKey;
  
  if (!autoPostEnabled) {
    return { canPost: false, reason: 'Auto-posting is disabled' };
  }
  
  if (!openaiApiKey) {
    return { canPost: false, reason: 'OpenAI API key not configured' };
  }
  
  // Check daily limit
  const today = new Date().toDateString();
  const postsToday = blogsData.blogs.filter(b => 
    b.isAutoGenerated && 
    b.publishedAt && 
    new Date(b.publishedAt).toDateString() === today
  ).length;
  
  if (postsToday >= settings.maxPostsPerDay) {
    return { canPost: false, reason: `Daily limit reached (${settings.maxPostsPerDay} posts)` };
  }
  
  // Check minimum interval
  if (blogsData.lastPostTime) {
    const lastPost = new Date(blogsData.lastPostTime);
    const minInterval = settings.postIntervalMinutes * 60 * 1000;
    const timeSinceLastPost = Date.now() - lastPost.getTime();
    
    if (timeSinceLastPost < minInterval) {
      const waitMinutes = Math.ceil((minInterval - timeSinceLastPost) / 60000);
      return { canPost: false, reason: `Must wait ${waitMinutes} more minutes` };
    }
  }
  
  return { canPost: true };
}

// Run scheduled post
export async function runScheduledPost() {
  console.log('[Scheduler] Starting scheduled post...');
  
  // Check if we can post
  const postCheck = await canPost();
  if (!postCheck.canPost) {
    console.log(`[Scheduler] Cannot post: ${postCheck.reason}`);
    return { success: false, reason: postCheck.reason };
  }
  
  try {
    // Get next keyword
    const keyword = await getNextKeyword();
    console.log(`[Scheduler] Selected keyword: ${keyword}`);
    
    // Generate title
    const title = await generateTitle(keyword);
    console.log(`[Scheduler] Generated title: ${title}`);
    
    // Generate content
    let content = await generateBlogContent(keyword);
    const originalContent = content;
    console.log('[Scheduler] Generated content');
    
    // Humanize content
    try {
      content = await humanizeText(content);
      console.log('[Scheduler] Humanized content');
    } catch (humanizeError) {
      console.warn('[Scheduler] Humanization failed, using original:', humanizeError.message);
    }
    
    // Generate meta description
    const metaDescription = await generateMetaDescription(title, content);
    
    // Generate tags
    const tags = await generateTags(content, keyword);
    
    // Generate slug
    const slug = generateSlug(keyword, title);
    
    // Create blog entry
    const newBlog = {
      id: uuidv4(),
      title,
      slug,
      metaDescription,
      content,
      originalContent,
      tags,
      category: 'Business Incorporation',
      keyword,
      status: 'published',
      isAutoGenerated: true,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      publishedAt: new Date().toISOString(),
      views: 0
    };
    
    // Save to blogs
    const blogsData = await getBlogsData();
    blogsData.blogs.unshift(newBlog);
    blogsData.lastPostTime = new Date().toISOString();
    await saveBlogsData(blogsData);
    
    console.log(`[Scheduler] Successfully published: ${title}`);
    
    return {
      success: true,
      blog: {
        id: newBlog.id,
        title: newBlog.title,
        slug: newBlog.slug,
        keyword: newBlog.keyword
      }
    };
    
  } catch (error) {
    console.error('[Scheduler] Error:', error);
    return { success: false, reason: error.message };
  }
}

// Get scheduler status
export async function getSchedulerStatus() {
  const settings = await getSettings();
  const blogsData = await getBlogsData();
  
  const today = new Date().toDateString();
  const postsToday = blogsData.blogs.filter(b => 
    b.isAutoGenerated && 
    b.publishedAt && 
    new Date(b.publishedAt).toDateString() === today
  ).length;
  
  let nextPostTime = null;
  if (settings.autoPostEnabled && blogsData.lastPostTime) {
    const lastPost = new Date(blogsData.lastPostTime);
    nextPostTime = new Date(lastPost.getTime() + settings.postIntervalMinutes * 60 * 1000);
  }
  
  return {
    autoPostEnabled: settings.autoPostEnabled,
    postIntervalMinutes: settings.postIntervalMinutes,
    maxPostsPerDay: settings.maxPostsPerDay,
    postsToday,
    lastPostTime: blogsData.lastPostTime,
    nextPostTime: nextPostTime?.toISOString(),
    canPost: (await canPost()).canPost
  };
}
